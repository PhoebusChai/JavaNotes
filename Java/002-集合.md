## 数组与集合的区别？

数组和集合的区别：

- 数组是固定长度的数据结构，一旦创建就无法改变；而集合是动态长度的数据结构，可以更具需求动态增加或减少元素。
- 数组可以包含基本数据类型和对象，而集合只能包含对象。
- 数组可以直接访问元素，而集合需要使用迭代器或其他方法才能访问元素。

## 常用集合有哪些？

1. ArrayList：动态数组，实现了 List 接口，支持动态增长。
2. LinkedList：双向链表，也实现了 List 接口，支持快速插入和删除。
3. HashMap：基于哈希表的 Map 实现，存储键值对，通过键快速获取值。
4. HashSet：基于哈希表的 Set 实现，存储唯一元素，通过元素快速判断是否包含。
5. TreeMap：基于红黑树实现的有序 Map 实现，存储键值对，通过键排序。
6. LinkedHashMap：基于哈希表表和双向链表的 Map 实现，保持插入顺序或访问顺序。
7. PriorityQueue：优先级队列，可以按照比较器或元素的自然顺序排序。

## Java 中的集合体系？

![集合体系](../static/image/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp)

List 是有序的 Collection，使用此接口能够精确地控制每个元素的插入位置，用户能够根据索引访问 List 中的元素.常用的 List 实现类有 ArrayList、LinkedList、Vector、Stack。

- ArrayList：是动态数组，线程不安全，允许重复元素，允许 null 元素，查询效率较高，增删效率较低。
- LinkedList：是双向链表，线程不安全，允许重复元素，允许 null 元素，查询效率较低，增删效率较高。
- Vector：是动态数组，线程安全，不允许重复元素，不允许 null 元素，查询效率较高，增删效率较低。
- Stack：是 Vector 的子类，线程安全，不允许重复元素，不允许 null 元素，查询效率较低，增删效率较高。

Set 不允许存在重复元素，与 List 不同，Set 集合中的元素是无序的，不能通过索引访问元素。常用的 Set 实现类有 HashSet、LinkedHashSet、TreeSet。

- HashSet：通过 HashMap 实现，线程不安全，不允许重复元素，允许 null 元素，查询效率较高，增删效率较低。
- LinkedHashSet：通过 LinkedHashMap 实现，线程不安全，不允许重复元素，允许 null 元素，查询效率较低，增删效率较高。使用双向列表保存元素的插入顺序。
- TreeSet：通过 TreeMap 实现，线程不安全，不允许重复元素，不允许 null 元素，查询效率较低，增删效率较高。使用红黑树保存元素的排序顺序。

Map 是一个键值对集合，存储键值对。Key 无序唯一，Value 无序，允许重复。Map 没有继承于 Collection 接口，不能使用 foreach 循环遍历。从 map 中获取元素时，需要使用 Key 进行索引。常用的 Map 实现类有 HashMap、LinkedHashMap、TreeMap、Hashtable、Properties。

- HashMap：由数组+列表实现，数组的主体是 HashMap 的主体，列表主要是解决哈希冲突。JDK1.8 以后，数组+链表+红黑树，当链表长度超过 8 时，将链表转换为红黑树，以提升查询效率。
- LinkedHashMap：LinkedHashMap 继承于 HashMap，继承了 HashMap 的所有功能，并且还维护了一条双向链表，用于记录元素的插入顺序。
- HashTable：数组+链表实现，线程安全，不允许 null 键和 null 值，查询效率较低，增删效率较低。
- TreeMap：红黑树实现，线程不安全，不允许 null 键和 null 值，查询效率较高，增删效率较低。
- Properties: Node 数组+链表+红黑树实现，线程安全，允许 null 键和 null 值，查询效率较高，增删效率较低。

## Java 中线程安全的集合是什么？

在 java.util 包中，线程安全的类主要有 2 个，其他都是非线程安全的。

- Vector：线程安全的动态数组，其内部方法都是经过 synchronized 修饰的，如果不需要线程安全，并不建议选择，毕竟同步块会影响性能。Vector 内部是使用数组来保存数据，可以更具需求动态增加或减少元素。当数组容量不够时，会创建一个新的数组，将原数组中的元素复制到新数组中，并释放原数组。
- HashTable：线程安全的哈希表，HasTable 的加锁方法是给每个方法加上 synchronized 关键字，这样锁住的是整个 Table 对象,不支持迭代器，不支持 null 键和 null 值。由于 HashTable 的效率较低，不建议使用。如果要保证线程安全，建议使用 ConcurrentHashMap。

java.util.concurrent 包中提供了线程安全的集合类，如 ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentSkipListMap、ConcurrentSkipListSet 等。这些集合类都继承于 AbstractCollection 类，实现了 Collection 接口。这些集合类都提供了线程安全的方法，如 putIfAbsent()、replace()、remove()、contains()等。这些方法都使用了锁机制，保证线程安全。

## Collections 和 Collection 的区别？

- Collections：是 java.util 包下的一个类，提供了一系列静态方法，用于操作集合对象。Collections 类提供了一系列静态方法，用于对集合对象进行操作，如排序、查找、修改、删除等。这些方法对可以实现了 Collection 接口的类进行操作。
- Collection：是 java.util 包下的一个接口，定义了集合类的基本操作。Collection 接口定义了集合类的基本操作，如添加、删除、修改、查找、遍历等。Collection 接口的实现类有 ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap 等。

## 集合的遍历方式有哪些？

- **普通 forr 循环**：可以使用带有索引的 for 循环来遍历 List。

```
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
list.add("c");

for (int i = 0; i < list.size(); i++) {
  System.out.println(list.get(i));
}
```

- **增强 for 循环**：可以使用增强 for 循环来遍历 List。

```
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
list.add("c");

for (String s : list) {
  System.out.println(s);
}
```

- **Iterator 迭代器**：可以使用迭代器来遍历 List,特别适合用于需要删除集合中的元素。

```
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
list.add("c");

Iterator<String> iterator = list.iterator();

while (iterator.hasNext()) {
  String s = iterator.next();
  System.out.println(s);
}
```

- **ListIterator**：ListIterator 是 Iterator 的子接口，提供了额外的方法，如 hasPrevious()、previous()、nextIndex()、previousIndex()等。可以修改集合中的元素。

```
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
list.add("c");

ListIterator<String> iterator = list.listIterator();

while (iterator.hasNext()) {
  String s = iterator.next();
  System.out.println(s);
}
```

- **forEach()方法**：可以使用 forEach()方法来遍历 List。

```
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
list.add("c");

list.forEach(System.out::println);
```

- **Stream API**：可以使用 Stream API 来遍历 List。Stream API 提供了丰富的方法，如 filter()、map()、sorted()、limit()、skip()、flatMap()、distinct()、peek()、count()、max()、min()、anyMatch()、allMatch()、noneMatch()、findFirst()、findAny()、toArray()、collect()、reduce()等。

```
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
list.add("c");

list.stream().forEach(System.out::println);
```

## 常见的常见的 List 集合

### 非线程安全

- ArrayList：线程不安全，非线程安全，ArrayList 的实现原理是数组，数组的长度是固定的，当数组的长度不够时，会创建一个新的数组，将原数组中的元素复制到新数组中，并释放原数组。
- LinkedList：线程不安全，非线程安全，LinkedList 的实现原理是链表，链表的长度是动态的，当链表的长度不够时，会创建一个新的链表，将原链表的元素复制到新链表中，并释放原链表。

### 线程安全

- Vector：线程安全，Vector 的实现原理是数组，数组的长度是固定的，当数组的长度不够时，会创建一个新的数组，将原数组中的元素复制到新数组中，并释放原数组。
- CopyOnWriteArrayList：在对数据进行修改的时候，会创建一个新的数组，将修改应用到新的数组中，而读操作仍然在原数组中执行，从而实现线程安全。而且实现了读写分离，提高了并发性能。适用于。

## 讲一下 Java 里面 List 集合的几种实现，几种实现的区别？

在 Java 中 List 集合的几种实现，几种实现的区别如下：

![](../static/image/1721807143695-c1058186-be42-4746-a273-6302a128e328.webp)

- Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步块会影响性能。Vector 内部是使用数组来保存数据，可以更具需求动态增加或减少元素。当数组容量不够时，会创建一个新的数组，将原数组中的元素复制到新数组中，并释放原数组。
- ArrayList 是应用更加广泛的动态数组，内部使用数组来保存数据，可以更具需求动态增加或减少元素。当数组容量不够时，会创建一个新的数组，将原数组中的元素复制到新数组中，并释放原数组。不过和 Vector 不一样的是，Vector 的扩容会提高 2 倍，ArrayList 的扩容是 1.5 倍。
- LinkedList 是 Java 集合中的一个链表实现，内部使用链表来保存数据，可以更具需求动态增加或减少元素。LinkedList 的实现原理是链表，链表长度是动态的，所以它不需要向 Vector 和 ArrayList 进行扩容,当链表长度不够时，会创建一个新的链表，将原链表的元素复制到新链表中，并释放原链表。

## List 可以一边遍历一边修改元素吗？

在 Java 中，List 在遍历过程中是否可以修改元素，这取决于遍历的方式和具体的 List 实现类，以下是几种常见的情况：

- **使用普通 for 循环遍历**：可以在遍历过程中修改元素，只要索引不超出 List 的范围即可。
- **使用迭代器遍历**：可以在遍历过程中修改元素，但是需要使用迭代器的 remove()方法来删除元素。
